window.Tags = [];
window.IDToTagList = [];

var JSON_game = {
  Extensions: [], ExtensionOptions: {}, Sounds: [], AudioGroups: [{ name: "audiogroup_default", enabled: true, }], Sprites: [], EmbeddedEntries: { "fallbacktexture": 0, "pt_shape_smoke": 4, "pt_shape_circle": 6, "pt_shape_cloud": 13, "pt_shape_line": 14, "pt_shape_disk": 7, "pt_shape_star": 12, "pt_shape_flare": 3, "pt_shape_ring": 8, "pt_shape_sphere": 11, "pt_shape_snow": 10, "pt_shape_square": 9, "pt_shape_explosion": 2, "pt_shape_pixel": 15, "pt_shape_spark": 5, "FONT_builtin": 1 }
  , Backgrounds: [], Paths: [], Shaders: [{
    name: "__yy_sdf_shader", Vertex: "#define LOWPREC lowp\n#define	MATRIX_VIEW 					0\n#define	MATRIX_PROJECTION 				1\n#define	MATRIX_WORLD 					2\n#define	MATRIX_WORLD_VIEW 				3\n#define	MATRIX_WORLD_VIEW_PROJECTION 	4\n#define	MATRICES_MAX					5\n\nuniform mat4 gm_Matrices[MATRICES_MAX]; \n\nuniform bool gm_LightingEnabled;\nuniform bool gm_VS_FogEnabled;\nuniform float gm_FogStart;\nuniform float gm_RcpFogRange;\n\n#define MAX_VS_LIGHTS	8\n#define MIRROR_WIN32_LIGHTING_EQUATION\n\n\n//#define	MAX_VS_LIGHTS					8\nuniform vec4   gm_AmbientColour;							// rgb=colour, a=1\nuniform vec4   gm_Lights_Direction[MAX_VS_LIGHTS];		// normalised direction\nuniform vec4   gm_Lights_PosRange[MAX_VS_LIGHTS];			// X,Y,Z position,  W range\nuniform vec4   gm_Lights_Colour[MAX_VS_LIGHTS];			// rgb=colour, a=1\n\nfloat CalcFogFactor(vec4 pos)\n{\n	if (gm_VS_FogEnabled)\n	{\n		vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\n		float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\n		return fogfactor;\n	}\n	else\n	{\n		return 0.0;\n	}\n}\n\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\n{\n	float dotresult = dot(ws_normal, dir.xyz);\n	dotresult = min(dotresult, dir.w);			// the w component is 1 if the directional light is active, or 0 if it isn't\n	dotresult = max(0.0, dotresult);\n\n	return dotresult * diffusecol;\n}\n\nvec4 DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\n{\n	vec3 diffvec = ws_pos - posrange.xyz;\n	float veclen = length(diffvec);\n	diffvec /= veclen;	// normalise\n	float atten;\n	if (posrange.w == 0.0)		// the w component of posrange is 0 if the point light is disabled - if we don't catch it here we might end up generating INFs or NaNs\n	{\n		atten = 0.0;\n	}\n	else\n	{\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\n	// This is based on the Win32 D3D and OpenGL falloff model, where:\n	// Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\n	// For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\n	// This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\n	\n		atten = 1.0 / (veclen / posrange.w);\n		if (veclen > posrange.w)\n		{\n			atten = 0.0;\n		}	\n#else\n		atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0);		// storing 1.0f/range instead would save a rcp\n#endif\n	}\n	float dotresult = dot(ws_normal, diffvec);\n	dotresult = max(0.0, dotresult);\n\n	return dotresult * atten * diffusecol;\n}\n\nvec4 DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\n{\n	if (gm_LightingEnabled)\n	{\n		// Normally we'd have the light positions\\directions back-transformed from world to object space\n		// But to keep things simple for the moment we'll just transform the normal to world space\n		vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\n		vec3 ws_normal;\n		ws_normal = (gm_Matrices[MATRIX_WORLD] * objectspacenormal4).xyz;\n		ws_normal = normalize(ws_normal);\n\n		vec3 ws_pos;\n		ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\n\n		// Accumulate lighting from different light types\n		vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0);		\n		for(int i = 0; i < MAX_VS_LIGHTS; i++)\n		{\n			accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\n		}\n\n		for(int i = 0; i < MAX_VS_LIGHTS; i++)\n		{\n			accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\n		}\n\n		accumcol *= vertexcolour;\n		accumcol += gm_AmbientColour;\n		accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\n		accumcol.a = vertexcolour.a;\n		return accumcol;\n	}\n	else\n	{\n		return vertexcolour;\n	}\n}\n\n#define _YY_GLSLES_ 1\n//\n// SDF vertex shader\n//\nattribute vec3 in_Position;                  // (x,y,z)\n//attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.\nattribute vec4 in_Colour;                    // (r,g,b,a)\nattribute vec2 in_TextureCoord;              // (u,v)\n\nvarying vec2 v_vTexcoord;\nvarying vec4 v_vColour;\n\nvoid main()\n{\n    vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\n    gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\n    \n    v_vColour = in_Colour;\n    v_vTexcoord = in_TextureCoord;\n}\n",
    Fragment: "precision mediump float;\n#define LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform bool gm_PS_FogEnabled;\nuniform vec4 gm_FogColour;\nuniform bool gm_AlphaTestEnabled;\nuniform float gm_AlphaRefValue;\n\nvoid DoAlphaTest(vec4 SrcColour)\n{\n	if (gm_AlphaTestEnabled)\n	{\n		if (SrcColour.a <= gm_AlphaRefValue)\n		{\n			discard;\n		}\n	}\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n	if (gm_PS_FogEnabled)\n	{\n		SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); \n	}\n}\n\n#define _YY_GLSLES_ 1\n//\n// SDF fragment shader\n//\nvarying vec2 v_vTexcoord;\nvarying vec4 v_vColour;\n\nvoid main()\n{\n	vec4 texcol = texture2D( gm_BaseTexture, v_vTexcoord );\n	\n	float spread = fwidth(texcol.a);	\n	spread = max(spread * 0.75, 0.001);	\n	texcol.a = smoothstep(0.5 - spread, 0.5 + spread, texcol.a);			\n	\n	vec4 combinedcol = v_vColour * texcol;\n	DoAlphaTest(combinedcol);	\n			\n    gl_FragColor = combinedcol;\n}\n",
    Attributes: ["in_Position", "in_Colour", "in_TextureCoord"]
  }, {
    name: "__yy_sdf_effect_shader", Vertex: "#define LOWPREC lowp\n#define	MATRIX_VIEW 					0\n#define	MATRIX_PROJECTION 				1\n#define	MATRIX_WORLD 					2\n#define	MATRIX_WORLD_VIEW 				3\n#define	MATRIX_WORLD_VIEW_PROJECTION 	4\n#define	MATRICES_MAX					5\n\nuniform mat4 gm_Matrices[MATRICES_MAX]; \n\nuniform bool gm_LightingEnabled;\nuniform bool gm_VS_FogEnabled;\nuniform float gm_FogStart;\nuniform float gm_RcpFogRange;\n\n#define MAX_VS_LIGHTS	8\n#define MIRROR_WIN32_LIGHTING_EQUATION\n\n\n//#define	MAX_VS_LIGHTS					8\nuniform vec4   gm_AmbientColour;							// rgb=colour, a=1\nuniform vec4   gm_Lights_Direction[MAX_VS_LIGHTS];		// normalised direction\nuniform vec4   gm_Lights_PosRange[MAX_VS_LIGHTS];			// X,Y,Z position,  W range\nuniform vec4   gm_Lights_Colour[MAX_VS_LIGHTS];			// rgb=colour, a=1\n\nfloat CalcFogFactor(vec4 pos)\n{\n	if (gm_VS_FogEnabled)\n	{\n		vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\n		float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\n		return fogfactor;\n	}\n	else\n	{\n		return 0.0;\n	}\n}\n\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\n{\n	float dotresult = dot(ws_normal, dir.xyz);\n	dotresult = min(dotresult, dir.w);			// the w component is 1 if the directional light is active, or 0 if it isn't\n	dotresult = max(0.0, dotresult);\n\n	return dotresult * diffusecol;\n}\n\nvec4 DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\n{\n	vec3 diffvec = ws_pos - posrange.xyz;\n	float veclen = length(diffvec);\n	diffvec /= veclen;	// normalise\n	float atten;\n	if (posrange.w == 0.0)		// the w component of posrange is 0 if the point light is disabled - if we don't catch it here we might end up generating INFs or NaNs\n	{\n		atten = 0.0;\n	}\n	else\n	{\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\n	// This is based on the Win32 D3D and OpenGL falloff model, where:\n	// Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\n	// For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\n	// This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\n	\n		atten = 1.0 / (veclen / posrange.w);\n		if (veclen > posrange.w)\n		{\n			atten = 0.0;\n		}	\n#else\n		atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0);		// storing 1.0f/range instead would save a rcp\n#endif\n	}\n	float dotresult = dot(ws_normal, diffvec);\n	dotresult = max(0.0, dotresult);\n\n	return dotresult * atten * diffusecol;\n}\n\nvec4 DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\n{\n	if (gm_LightingEnabled)\n	{\n		// Normally we'd have the light positions\\directions back-transformed from world to object space\n		// But to keep things simple for the moment we'll just transform the normal to world space\n		vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\n		vec3 ws_normal;\n		ws_normal = (gm_Matrices[MATRIX_WORLD] * objectspacenormal4).xyz;\n		ws_normal = normalize(ws_normal);\n\n		vec3 ws_pos;\n		ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\n\n		// Accumulate lighting from different light types\n		vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0);		\n		for(int i = 0; i < MAX_VS_LIGHTS; i++)\n		{\n			accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\n		}\n\n		for(int i = 0; i < MAX_VS_LIGHTS; i++)\n		{\n			accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\n		}\n\n		accumcol *= vertexcolour;\n		accumcol += gm_AmbientColour;\n		accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\n		accumcol.a = vertexcolour.a;\n		return accumcol;\n	}\n	else\n	{\n		return vertexcolour;\n	}\n}\n\n#define _YY_GLSLES_ 1\n//\n// Simple passthrough vertex shader\n//\nattribute vec3 in_Position;                  // (x,y,z)\n//attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.\nattribute vec4 in_Colour;                    // (r,g,b,a)\nattribute vec2 in_TextureCoord;              // (u,v)\n\nvarying vec2 v_vTexcoord;\nvarying vec4 v_vColour;\n\nvoid main()\n{\n    vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\n    gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\n    \n    v_vColour = in_Colour;\n    v_vTexcoord = in_TextureCoord;\n}\n",
    Fragment: "precision mediump float;\n#define LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform bool gm_PS_FogEnabled;\nuniform vec4 gm_FogColour;\nuniform bool gm_AlphaTestEnabled;\nuniform float gm_AlphaRefValue;\n\nvoid DoAlphaTest(vec4 SrcColour)\n{\n	if (gm_AlphaTestEnabled)\n	{\n		if (SrcColour.a <= gm_AlphaRefValue)\n		{\n			discard;\n		}\n	}\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n	if (gm_PS_FogEnabled)\n	{\n		SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); \n	}\n}\n\n#define _YY_GLSLES_ 1\n//\n// SDF (with effects) fragment shader\n//\nvarying vec2 v_vTexcoord;\nvarying vec4 v_vColour;\n\n// SDF values are measured from 0 (at the outer edge) to 1 which is the innermost point that can be represented\nuniform bool gm_SDF_DrawGlow;				// whether the glow effect is enabled\nuniform vec2 gm_SDF_Glow_MinMax;			// the SDF range across which the glow fades\nuniform vec4 gm_SDF_Glow_Col;				// the colour of the glow\n\nuniform bool gm_SDF_DrawOutline;			// whether the outline effect is enabled\nuniform float gm_SDF_Outline_Thresh;		// the SDF distance which represents the outer edge of the outline\nuniform vec4 gm_SDF_Outline_Col;			// the colour of the outline\n\nuniform float gm_SDF_Core_Thresh;			// the SDF distance which represents the outer edge the shape\nuniform vec4 gm_SDF_Core_Col;				// the colour of the core part of the shape\n\nvoid main()\n{\n	vec4 texcol = texture2D( gm_BaseTexture, v_vTexcoord );\n		\n	float pixelspread = fwidth(texcol.a);	\n	pixelspread = max(pixelspread * 0.75, 0.001);	\n	\n	float blendfactor;\n	vec4 currcol = vec4(0.0, 0.0, 0.0, -1.0);\n	\n	// Handle glow effect\n	if (gm_SDF_DrawGlow)\n	{		\n		if (texcol.a > gm_SDF_Glow_MinMax.x)\n		{\n			currcol = gm_SDF_Glow_Col;\n			currcol.a *= smoothstep(gm_SDF_Glow_MinMax.x, gm_SDF_Glow_MinMax.y, texcol.a);\n		}\n	}	\n	\n	// Handle outline effect\n	if (gm_SDF_DrawOutline)\n	{\n		if (texcol.a > (gm_SDF_Outline_Thresh - pixelspread))\n		{			\n			blendfactor = smoothstep(gm_SDF_Outline_Thresh - pixelspread, gm_SDF_Outline_Thresh + pixelspread, texcol.a);\n			if (currcol.a < 0.0)\n			{\n				currcol = vec4(gm_SDF_Outline_Col.r,gm_SDF_Outline_Col.g,gm_SDF_Outline_Col.b, 0.0);\n			}\n			currcol = mix(currcol, gm_SDF_Outline_Col, blendfactor);\n		}\n	}\n	\n	// Handle inner core\n	blendfactor = smoothstep(gm_SDF_Core_Thresh - pixelspread, gm_SDF_Core_Thresh + pixelspread, texcol.a);\n	\n	if (currcol.a < 0.0)\n	{\n		currcol = vec4(gm_SDF_Core_Col.r,gm_SDF_Core_Col.g,gm_SDF_Core_Col.b, 0.0);\n	}\n	texcol = mix(currcol, gm_SDF_Core_Col, blendfactor);	\n	\n	vec4 combinedcol = v_vColour * texcol;\n	DoAlphaTest(combinedcol);	\n			\n    gl_FragColor = combinedcol;\n}\n",
    Attributes: ["in_Position", "in_Colour", "in_TextureCoord"]
  }, {
    name: "__yy_sdf_blur_shader", Vertex: "#define LOWPREC lowp\n#define	MATRIX_VIEW 					0\n#define	MATRIX_PROJECTION 				1\n#define	MATRIX_WORLD 					2\n#define	MATRIX_WORLD_VIEW 				3\n#define	MATRIX_WORLD_VIEW_PROJECTION 	4\n#define	MATRICES_MAX					5\n\nuniform mat4 gm_Matrices[MATRICES_MAX]; \n\nuniform bool gm_LightingEnabled;\nuniform bool gm_VS_FogEnabled;\nuniform float gm_FogStart;\nuniform float gm_RcpFogRange;\n\n#define MAX_VS_LIGHTS	8\n#define MIRROR_WIN32_LIGHTING_EQUATION\n\n\n//#define	MAX_VS_LIGHTS					8\nuniform vec4   gm_AmbientColour;							// rgb=colour, a=1\nuniform vec4   gm_Lights_Direction[MAX_VS_LIGHTS];		// normalised direction\nuniform vec4   gm_Lights_PosRange[MAX_VS_LIGHTS];			// X,Y,Z position,  W range\nuniform vec4   gm_Lights_Colour[MAX_VS_LIGHTS];			// rgb=colour, a=1\n\nfloat CalcFogFactor(vec4 pos)\n{\n	if (gm_VS_FogEnabled)\n	{\n		vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\n		float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\n		return fogfactor;\n	}\n	else\n	{\n		return 0.0;\n	}\n}\n\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\n{\n	float dotresult = dot(ws_normal, dir.xyz);\n	dotresult = min(dotresult, dir.w);			// the w component is 1 if the directional light is active, or 0 if it isn't\n	dotresult = max(0.0, dotresult);\n\n	return dotresult * diffusecol;\n}\n\nvec4 DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\n{\n	vec3 diffvec = ws_pos - posrange.xyz;\n	float veclen = length(diffvec);\n	diffvec /= veclen;	// normalise\n	float atten;\n	if (posrange.w == 0.0)		// the w component of posrange is 0 if the point light is disabled - if we don't catch it here we might end up generating INFs or NaNs\n	{\n		atten = 0.0;\n	}\n	else\n	{\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\n	// This is based on the Win32 D3D and OpenGL falloff model, where:\n	// Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\n	// For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\n	// This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\n	\n		atten = 1.0 / (veclen / posrange.w);\n		if (veclen > posrange.w)\n		{\n			atten = 0.0;\n		}	\n#else\n		atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0);		// storing 1.0f/range instead would save a rcp\n#endif\n	}\n	float dotresult = dot(ws_normal, diffvec);\n	dotresult = max(0.0, dotresult);\n\n	return dotresult * atten * diffusecol;\n}\n\nvec4 DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\n{\n	if (gm_LightingEnabled)\n	{\n		// Normally we'd have the light positions\\directions back-transformed from world to object space\n		// But to keep things simple for the moment we'll just transform the normal to world space\n		vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\n		vec3 ws_normal;\n		ws_normal = (gm_Matrices[MATRIX_WORLD] * objectspacenormal4).xyz;\n		ws_normal = normalize(ws_normal);\n\n		vec3 ws_pos;\n		ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\n\n		// Accumulate lighting from different light types\n		vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0);		\n		for(int i = 0; i < MAX_VS_LIGHTS; i++)\n		{\n			accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\n		}\n\n		for(int i = 0; i < MAX_VS_LIGHTS; i++)\n		{\n			accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\n		}\n\n		accumcol *= vertexcolour;\n		accumcol += gm_AmbientColour;\n		accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\n		accumcol.a = vertexcolour.a;\n		return accumcol;\n	}\n	else\n	{\n		return vertexcolour;\n	}\n}\n\n#define _YY_GLSLES_ 1\n//\n// Simple passthrough vertex shader\n//\nattribute vec3 in_Position;                  // (x,y,z)\n//attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.\nattribute vec4 in_Colour;                    // (r,g,b,a)\nattribute vec2 in_TextureCoord;              // (u,v)\n\nvarying vec2 v_vTexcoord;\nvarying vec4 v_vColour;\n\nvoid main()\n{\n    vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\n    gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\n    \n    v_vColour = in_Colour;\n    v_vTexcoord = in_TextureCoord;\n}\n",
    Fragment: "precision mediump float;\n#define LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform bool gm_PS_FogEnabled;\nuniform vec4 gm_FogColour;\nuniform bool gm_AlphaTestEnabled;\nuniform float gm_AlphaRefValue;\n\nvoid DoAlphaTest(vec4 SrcColour)\n{\n	if (gm_AlphaTestEnabled)\n	{\n		if (SrcColour.a <= gm_AlphaRefValue)\n		{\n			discard;\n		}\n	}\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n	if (gm_PS_FogEnabled)\n	{\n		SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); \n	}\n}\n\n#define _YY_GLSLES_ 1\n//\n// SDF (with blur) fragment shader\n//\nvarying vec2 v_vTexcoord;\nvarying vec4 v_vColour;\n\n// SDF values are measured from 0 (at the outer edge) to 1 which is the innermost point that can be represented\nuniform vec2 gm_SDF_Blur_MinMax;			// the range across which to filter the SDF\nuniform vec4 gm_SDF_Blur_Col;				// the colour tint of the blurred text\n\nvoid main()\n{\n	vec4 texcol = texture2D( gm_BaseTexture, v_vTexcoord );	\n	vec4 currcol = gm_SDF_Blur_Col;\n		\n	currcol.a *= smoothstep(gm_SDF_Blur_MinMax.x, gm_SDF_Blur_MinMax.y, texcol.a);		\n	\n	vec4 combinedcol = v_vColour * currcol;\n	DoAlphaTest(combinedcol);	\n\n    gl_FragColor = combinedcol;\n}\n",
    Attributes: ["in_Position", "in_Colour", "in_TextureCoord"]
  }], Fonts: [], EmbeddedFonts: [{
    pName: "FONT_builtin", size: 11, bold: false, italic: false, first: 32, last: 9647, charset: 0, antialias: 1, fontname: "Roboto Mono", ascenderOffset: 0, ascender: 0, sdfSpread: 0, lineHeight: 0, TPageEntry: 1, scaleX: 1, scaleY: 1, glyphs: [{ i: 32, c: " ", x: 2, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, { i: 33, c: "!", x: 127, y: 44, w: 3, h: 19, shift: 9, offset: 3 }, { i: 34, c: "\"", x: 120, y: 44, w: 5, h: 19, shift: 9, offset: 2 }, { i: 35, c: "#", x: 109, y: 44, w: 9, h: 19, shift: 9, offset: 0 }, {
      i: 36, c: "$",
      x: 100, y: 44, w: 7, h: 19, shift: 9, offset: 1
    }, { i: 37, c: "%", x: 89, y: 44, w: 9, h: 19, shift: 9, offset: 0 }, { i: 38, c: "&", x: 78, y: 44, w: 9, h: 19, shift: 9, offset: 0 }, { i: 39, c: "'", x: 74, y: 44, w: 2, h: 19, shift: 9, offset: 3 }, { i: 40, c: "(", x: 67, y: 44, w: 5, h: 19, shift: 9, offset: 2 }, { i: 41, c: ")", x: 60, y: 44, w: 5, h: 19, shift: 9, offset: 2 }, { i: 42, c: "*", x: 132, y: 44, w: 8, h: 19, shift: 9, offset: 1 }, { i: 43, c: "+", x: 49, y: 44, w: 9, h: 19, shift: 9, offset: 0 }, { i: 44, c: ",", x: 34, y: 44, w: 3, h: 19, shift: 9, offset: 2 }, { i: 45, c: "-", x: 25, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, {
      i: 46, c: ".", x: 20, y: 44,
      w: 3, h: 19, shift: 9, offset: 3
    }, { i: 47, c: "/", x: 11, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, { i: 48, c: "0", x: 2, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, { i: 49, c: "1", x: 245, y: 23, w: 5, h: 19, shift: 9, offset: 1 }, { i: 50, c: "2", x: 235, y: 23, w: 8, h: 19, shift: 9, offset: 0 }, { i: 51, c: "3", x: 225, y: 23, w: 8, h: 19, shift: 9, offset: 0 }, { i: 52, c: "4", x: 214, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 53, c: "5", x: 39, y: 44, w: 8, h: 19, shift: 9, offset: 1 }, { i: 54, c: "6", x: 142, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, { i: 55, c: "7", x: 151, y: 44, w: 9, h: 19, shift: 9, offset: 0 }, {
      i: 56, c: "8", x: 162, y: 44, w: 8,
      h: 19, shift: 9, offset: 1
    }, { i: 57, c: "9", x: 110, y: 65, w: 7, h: 19, shift: 9, offset: 1 }, { i: 58, c: ":", x: 105, y: 65, w: 3, h: 19, shift: 9, offset: 3 }, { i: 59, c: ";", x: 100, y: 65, w: 3, h: 19, shift: 9, offset: 3 }, { i: 60, c: "<", x: 91, y: 65, w: 7, h: 19, shift: 9, offset: 1 }, { i: 61, c: "=", x: 82, y: 65, w: 7, h: 19, shift: 9, offset: 1 }, { i: 62, c: ">", x: 73, y: 65, w: 7, h: 19, shift: 9, offset: 1 }, { i: 63, c: "?", x: 64, y: 65, w: 7, h: 19, shift: 9, offset: 1 }, { i: 64, c: "@", x: 53, y: 65, w: 9, h: 19, shift: 9, offset: 0 }, { i: 65, c: "A", x: 42, y: 65, w: 9, h: 19, shift: 9, offset: 0 }, {
      i: 66, c: "B", x: 32, y: 65, w: 8, h: 19, shift: 9,
      offset: 1
    }, { i: 67, c: "C", x: 21, y: 65, w: 9, h: 19, shift: 9, offset: 0 }, { i: 68, c: "D", x: 11, y: 65, w: 8, h: 19, shift: 9, offset: 1 }, { i: 69, c: "E", x: 2, y: 65, w: 7, h: 19, shift: 9, offset: 1 }, { i: 70, c: "F", x: 241, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, { i: 71, c: "G", x: 230, y: 44, w: 9, h: 19, shift: 9, offset: 0 }, { i: 72, c: "H", x: 221, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, { i: 73, c: "I", x: 212, y: 44, w: 7, h: 19, shift: 9, offset: 1 }, { i: 74, c: "J", x: 202, y: 44, w: 8, h: 19, shift: 9, offset: 0 }, { i: 75, c: "K", x: 192, y: 44, w: 8, h: 19, shift: 9, offset: 1 }, { i: 76, c: "L", x: 182, y: 44, w: 8, h: 19, shift: 9, offset: 1 }
      , { i: 77, c: "M", x: 172, y: 44, w: 8, h: 19, shift: 9, offset: 1 }, { i: 78, c: "N", x: 205, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 79, c: "O", x: 194, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 80, c: "P", x: 184, y: 23, w: 8, h: 19, shift: 9, offset: 1 }, { i: 81, c: "Q", x: 208, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, { i: 82, c: "R", x: 192, y: 2, w: 8, h: 19, shift: 9, offset: 1 }, { i: 83, c: "S", x: 181, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, { i: 84, c: "T", x: 170, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, { i: 85, c: "U", x: 161, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 86, c: "V", x: 150, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, {
      i: 87,
      c: "W", x: 139, y: 2, w: 9, h: 19, shift: 9, offset: 0
    }, { i: 88, c: "X", x: 128, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, { i: 89, c: "Y", x: 117, y: 2, w: 9, h: 19, shift: 9, offset: 0 }, { i: 90, c: "Z", x: 107, y: 2, w: 8, h: 19, shift: 9, offset: 0 }, { i: 91, c: "[", x: 202, y: 2, w: 4, h: 19, shift: 9, offset: 3 }, { i: 92, c: "\\", x: 98, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 93, c: "]", x: 82, y: 2, w: 4, h: 19, shift: 9, offset: 2 }, { i: 94, c: "^", x: 73, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 95, c: "_", x: 64, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 96, c: "`", x: 59, y: 2, w: 3, h: 19, shift: 9, offset: 3 }, {
      i: 97, c: "a", x: 50, y: 2,
      w: 7, h: 19, shift: 9, offset: 1
    }, { i: 98, c: "b", x: 41, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 99, c: "c", x: 32, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 100, c: "d", x: 23, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 101, c: "e", x: 13, y: 2, w: 8, h: 19, shift: 9, offset: 0 }, { i: 102, c: "f", x: 88, y: 2, w: 8, h: 19, shift: 9, offset: 1 }, { i: 103, c: "g", x: 219, y: 2, w: 7, h: 19, shift: 9, offset: 1 }, { i: 104, c: "h", x: 72, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 105, c: "i", x: 228, y: 2, w: 8, h: 19, shift: 9, offset: 1 }, { i: 106, c: "j", x: 167, y: 23, w: 6, h: 19, shift: 9, offset: 1 }, {
      i: 107, c: "k", x: 157, y: 23, w: 8, h: 19,
      shift: 9, offset: 1
    }, { i: 108, c: "l", x: 147, y: 23, w: 8, h: 19, shift: 9, offset: 1 }, { i: 109, c: "m", x: 136, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 110, c: "n", x: 127, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 111, c: "o", x: 116, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 112, c: "p", x: 107, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 113, c: "q", x: 98, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 114, c: "r", x: 90, y: 23, w: 6, h: 19, shift: 9, offset: 2 }, { i: 115, c: "s", x: 175, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 116, c: "t", x: 81, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, {
      i: 117, c: "u", x: 63, y: 23, w: 7,
      h: 19, shift: 9, offset: 1
    }, { i: 118, c: "v", x: 52, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 119, c: "w", x: 41, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 120, c: "x", x: 30, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 121, c: "y", x: 19, y: 23, w: 9, h: 19, shift: 9, offset: 0 }, { i: 122, c: "z", x: 10, y: 23, w: 7, h: 19, shift: 9, offset: 1 }, { i: 123, c: "{", x: 2, y: 23, w: 6, h: 19, shift: 9, offset: 2 }, { i: 124, c: "|", x: 246, y: 2, w: 3, h: 19, shift: 9, offset: 3 }, { i: 125, c: "}", x: 238, y: 2, w: 6, h: 19, shift: 9, offset: 2 }, { i: 126, c: "~", x: 119, y: 65, w: 9, h: 19, shift: 9, offset: 0 }, {
      i: 9647, c: "▯", x: 130, y: 65, w: 5,
      h: 19, shift: 8, offset: 1
    },],
  }], Timelines: [], ScriptNames: [], Triggers: [{}], GMObjects: [], AnimCurves: [], Sequences: [], FiltersAndEffectDefs: [], PSEmitters: [], ParticleSystems: [], GMRooms: [{
    pName: "Room1", width: 1366, speed: 0, colour: 0, LayerCount: 2, showColour: false, viewClearScreen: false, backgrounds: [], views: [{ wview: 1366, hview: 768, wport: 1366, hport: 768 }, { wview: 1366, hview: 768, wport: 1366, hport: 768 }, { wview: 1366, hview: 768, wport: 1366, hport: 768 }, { wview: 1366, hview: 768, wport: 1366, hport: 768 }, { wview: 1366, hview: 768, wport: 1366, hport: 768 }, {
      wview: 1366,
      hview: 768, wport: 1366, hport: 768
    }, { wview: 1366, hview: 768, wport: 1366, hport: 768 }, { wview: 1366, hview: 768, wport: 1366, hport: 768 }], pInstances: [], tiles: [], layers: [{ pName: "Instances", id: 0, type: 2, depth: 0, x: 0, y: 0, hspeed: 0, vspeed: 0, visible: 1, effectEnabled: 1, effectType: "", effectProperties: [], icount: 0, iinstIDs: [] }, {
      pName: "Background", id: 1, type: 1, depth: 100, x: 0, y: 0, hspeed: 0, vspeed: 0, visible: 1, effectEnabled: 1, effectType: "", effectProperties: [], bvisible: true, bforeground: false, bindex: -1, bhtiled: false, bvtiled: false, bstretch: false,
      bblend: -16777216, bimage_index: 0, bimage_speed: 15
    }]
  }], RoomOrder: [0], TPageEntries: [{ x: 0, y: 0, w: 64, h: 64, XOffset: 0, YOffset: 0, CropWidth: 64, CropHeight: 64, ow: 64, oh: 64, tp: 0 }, { x: 0, y: 4, w: 256, h: 128, XOffset: 0, YOffset: 0, CropWidth: 256, CropHeight: 128, ow: 256, oh: 128, tp: 1 }, { x: 4, y: 140, w: 64, h: 64, XOffset: 0, YOffset: 0, CropWidth: 64, CropHeight: 64, ow: 64, oh: 64, tp: 1 }, { x: 4, y: 212, w: 64, h: 64, XOffset: 0, YOffset: 0, CropWidth: 64, CropHeight: 64, ow: 64, oh: 64, tp: 1 }, {
    x: 4, y: 284, w: 64, h: 64, XOffset: 0, YOffset: 0, CropWidth: 64, CropHeight: 64, ow: 64,
    oh: 64, tp: 1
  }, { x: 4, y: 356, w: 64, h: 64, XOffset: 0, YOffset: 0, CropWidth: 64, CropHeight: 64, ow: 64, oh: 64, tp: 1 }, { x: 4, y: 428, w: 62, h: 62, XOffset: 1, YOffset: 1, CropWidth: 62, CropHeight: 62, ow: 64, oh: 64, tp: 1 }, { x: 76, y: 140, w: 62, h: 62, XOffset: 1, YOffset: 1, CropWidth: 62, CropHeight: 62, ow: 64, oh: 64, tp: 1 }, { x: 76, y: 210, w: 62, h: 62, XOffset: 1, YOffset: 1, CropWidth: 62, CropHeight: 62, ow: 64, oh: 64, tp: 1 }, { x: 76, y: 280, w: 62, h: 62, XOffset: 1, YOffset: 1, CropWidth: 62, CropHeight: 62, ow: 64, oh: 64, tp: 1 }, {
    x: 76, y: 350, w: 60, h: 64, XOffset: 2, YOffset: 0, CropWidth: 60,
    CropHeight: 64, ow: 64, oh: 64, tp: 1
  }, { x: 76, y: 422, w: 61, h: 61, XOffset: 2, YOffset: 2, CropWidth: 61, CropHeight: 61, ow: 64, oh: 64, tp: 1 }, { x: 146, y: 140, w: 62, h: 60, XOffset: 1, YOffset: 1, CropWidth: 62, CropHeight: 60, ow: 64, oh: 64, tp: 1 }, { x: 146, y: 208, w: 57, h: 57, XOffset: 3, YOffset: 4, CropWidth: 57, CropHeight: 57, ow: 64, oh: 64, tp: 1 }, { x: 146, y: 273, w: 62, h: 10, XOffset: 1, YOffset: 27, CropWidth: 62, CropHeight: 10, ow: 64, oh: 64, tp: 1 }, { x: 146, y: 291, w: 1, h: 1, XOffset: 31, YOffset: 31, CropWidth: 1, CropHeight: 1, ow: 64, oh: 64, tp: 1 }], Textures: [], TexturesBlocks: [{ MipsToGenerate: 0 }, { MipsToGenerate: 0 }], TextureGroupInfo: [{ pName: "__YY__0fallbacktexture.png_YYG_AUTO_GEN_TEX_GROUP_NAME_", TextureIDs: [0], SpriteIDs: [], SpineSpriteIDs: [], FontIDs: [], TilesetIDs: [] }, { pName: "Default", TextureIDs: [1], SpriteIDs: [], SpineSpriteIDs: [], FontIDs: [], TilesetIDs: [] }], FeatureFlags: {
      "filt+fx": "filt+fx", "gx_mod_wallpaper": "gx_mod_wallpaper", "nullish": "nullish", "login_sso": "login_sso", "operagx-yyc": "operagx-yyc", "mqtt": "mqtt", "audio-fx": "audio-fx",
      "intellisense": "intellisense", "test": "test", "custom_env": "custom_env", "filt+fx": "filt+fx", "gx_mod_wallpaper": "gx_mod_wallpaper", "gx_mod_gamestrip": "gx_mod_gamestrip", "live_wallpaper_subscription": "live_wallpaper_subscription"
    }, Options: {
      debugMode: false, AssetCompilerMajorVersion: 2, AssetCompilerMinorVersion: 0, AssetCompilerBuildVersion: 0, GameSpeed: 60, DrawColour: 4294967295, xscreensize: 1366, yscreensize: 768, gameId: 0, gameGuid: "a4dc87c6-6183-40a7-b9d5-abe1f0aedb10", fullScreen: false, interpolatePixels: true,
      showCursor: true, scale: 1, allowFullScreenKey: true, freezeOnLostFocus: false, showLoadingBar: false, displayErrors: false, writeErrors: false, abortErrors: false, variableErrors: true, outputDebugToConsole: true, WebGL: 2, WebGLPreserveDrawingBuffer: 0, CollisionCompatibility: false, UseNewAudio: true, GameDir: "html5game", Config: "Default", ViewColour: 0, CreateEventOrder: false, UseParticles: true, UseBuiltinFont: true, LocalRunAlert: true, crc: 0, ProjectName: "BLANK GAME", md5: [189, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], MajorVersion: 1, MinorVersion: 0,
      BuildVersion: 0, RevisionVersion: 0, DisplayName: "Created with GameMaker", UseFBExtension: false, tm: 1718708152, AllowStatistics: "True"
    }
};
